# Results Viewer Documentation

## Overview
The ResultsViewer component is designed to render structured output from an AI engine that processes templates defined according to our workflow-based approach. It handles nested workflows, data visualization, and maintains a hierarchical display of information.

## Engine Response Structure

### Core Components
1. **Results Object**: Contains the actual data organized by workflows
2. **Titles Object**: Contains display information for workflows and their data fields

### Workflow Identification
A workflow is identified by two key characteristics:
1. The presence of a corresponding entry in the `titles` object
2. A `workflow` key in that titles entry defining the display name

For example:
```json
{
  "titles": {
    "main": {
      "workflow": "Entry Point",  // This identifies "main" as a workflow
      "data": { ... }
    }
  }
}
```

### Nested Workflows
Workflows can be nested within other workflows. For example, `interview-meeting` is a child workflow of `main`. The hierarchy is maintained in both the results and titles objects.

## Component Implementation

### Main ResultsViewer Component

```11:38:src/components/ResultsViewer/index.tsx
export default function ResultsViewer({ data }: ResultsViewerProps) {
  const { results, titles } = data

  const renderWorkflows = (results: any, titles: any, path: string = '') => {
    return Object.entries(results).map(([key, value]) => {
      const currentTitles = path ? titles[key] : titles[key]
      
      if (currentTitles) {
        return (
          <WorkflowSection
            key={key}
            title={currentTitles.workflow || key}
            data={value}
            titles={currentTitles}
            path={path ? `${path}.${key}` : key}
          />
        )
      }
      return null
    })
  }

  return (
      <Stack spacing={2}>
        {renderWorkflows(results, titles)}
      </Stack>
  )
}
```


The main component uses recursive rendering to handle nested workflows through the `renderWorkflows` function. It:
1. Extracts results and titles from the engine response
2. Maps through results to identify workflows
3. Passes workflow data to `WorkflowSection` components

### Workflow Section

```17:56:src/components/ResultsViewer/WorkflowSection.tsx
export default function WorkflowSection({ 
  title,
  data,
  titles,
  path,
}: WorkflowSectionProps) {
  return (
    <Paper sx={{ p: 2, borderRadius: 2 }}>
      <Box sx={{ 
        display: 'flex', 
        alignItems: 'center', 
        mb: 2,
        pb: 1.5,
        borderBottom: '1px solid',
        borderColor: 'divider'
      }}>
        <AccountTreeIcon 
          sx={{ 
            mr: 1,
            color: 'primary.main'
          }} 
        />
        <Typography 
          variant="h6" 
          fontWeight="500"
          sx={{
            color: 'primary.main',
            letterSpacing: '0.02em'
          }}
        >
          {title}
        </Typography>
      </Box>
      
      <Box sx={{ pl: 2 }}>
        <DataRenderer data={data} titles={titles.data} path={path} />
      </Box>
    </Paper>
  )
}
```


WorkflowSection handles the display of individual workflows by:
1. Rendering the workflow title with an icon
2. Using DataRenderer to display the workflow's data

### Data Rendering System

The data rendering system is hierarchical and type-aware:

1. **DataRenderer**: Entry point for rendering all data types

```44:58:src/components/ResultsViewer/DataRenderer.tsx
export default function DataRenderer({ data, titles, path }: DataRendererProps) {
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
      {Object.entries(data).map(([key, value]) => (
        <ValueRenderer
          key={key}
          keyName={key}
          value={value}
          title={titles[key]}
          path={path}
        />
      ))}
    </Box>
  )
}
```


2. **Type-Specific Renderers**:
- `BaseTypeRenderer`: For primitive types (strings, numbers)
- `ListRenderer`: For arrays
- `ObjectRenderer`: For nested objects
- `ObjectTableRenderer`: For arrays of objects

### Title Resolution

Titles are resolved in two ways:

1. **Explicit Titles**: Defined in the titles object:
```json
{
  "titles": {
    "main": {
      "data": {
        "participants": "Meeting Participants"
      }
    }
  }
}
```

2. **Auto-generated Titles**: When titles aren't explicitly defined, they're generated by transforming the key:

```38:42:src/components/ResultsViewer/ObjectRenderer.tsx
          titles={Object.keys(data).reduce((acc, key) => {
            acc[key] = key.charAt(0).toUpperCase() + key.slice(1).replace(/-/g, ' ')
            return acc
          }, {} as Record<string, string>)} 
          path={path} 
```


## Relationship to Template System

The ResultsViewer complements the template generation system by:

1. **Workflow Alignment**: Renders data according to the workflow structure defined in templates
2. **Data Type Handling**: Provides appropriate renderers for all supported data types
3. **Hierarchical Display**: Maintains the parent-child relationships defined in workflows

### Example Flow
1. Template defines data collection structure
2. AI Engine processes template and generates response
3. ResultsViewer renders response maintaining workflow hierarchy:
   - Main workflow ("Entry Point")
   - Child workflows (e.g., "Interview Meeting")
   - Data fields with appropriate visualizations

## Key Features

1. **Recursive Workflow Rendering**: Handles unlimited nesting of workflows
2. **Type-Aware Rendering**: Different visualization strategies for different data types
3. **Flexible Title System**: Supports both explicit and auto-generated titles
4. **Hierarchical Navigation**: Maintains parent-child relationships between workflows
5. **Consistent Styling**: Material-UI based components for a cohesive look

## Usage Example

```typescript
<ResultsViewer data={engineResponse} />
```

Where `engineResponse` follows the structure with `results` and `titles` objects, maintaining workflow hierarchy and data organization as defined in the template system.